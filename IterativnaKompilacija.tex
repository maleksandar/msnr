% !TEX encoding = UTF-8 Unicode

\documentclass[a4paper]{article}

\usepackage{color}
\usepackage{url}
\usepackage[T2A]{fontenc} % enable Cyrillic fonts
\usepackage[utf8]{inputenc} % make weird characters work
\usepackage{graphicx}

\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\usepackage[english,serbian]{babel}
%\usepackage[english,serbianc]{babel} %ukljuciti babel sa ovim opcijama, umesto gornjim, ukoliko se koristi cirilica

\usepackage[unicode]{hyperref}
\hypersetup{colorlinks,citecolor=green,filecolor=green,linkcolor=blue,urlcolor=blue}

\begin{document}

\title{Optimizacija programa kroz različite pristupe Iterativnoj Kompilaciji\\ \small{Seminarski rad u okviru kursa\\Metodologija stručnog i naučnog rada\\ Matematički fakultet}}

\author{Filip Novović, Aleksandar Preočanin, Aleksandar Milosavljević\\ filipn@post.com, preocanin.aleksandar@gmail.com, alemilosav@gmail.com }
\date{14.~april 2017.}
\maketitle

\abstract{
U ovom tekstu je ukratko prikazana osnovna forma seminarskog rada. Obratite pažnju da je pored ove .pdf datoteke, u prilogu i odgovarajuća .tex datoteka, kao i .bib datoteka korišćena za generisanje literature. Na prvoj strani seminarskog rada su naslov, apstrakt i sadržaj, i to sve mora da stane na prvu stranu! Kako bi Vaš seminarski zadovoljio standarde i očekivanja, koristite uputstva i materijale sa predavanja na temu pisanja seminarskih radova. Ovo je samo šablon koji se odnosi na fizički izgled seminarskog rada (šablon koji \emph{morate} da ispoštujete!) kao i par tehničkih pomoćnih uputstava. Molim Vas da kada budete predavali seminarski rad, imenujete datoteke tako da sadrže temu seminarskog rada, kao i imena i prezimena članova grupe (ili samo temu i prezimena, ukoliko je sa imenima predugačko). Predaja seminarskih radova biće isključivo preko web forme, a NE slanjem mejla.

\tableofcontents

\newpage

\section{Uvod}
\label{sec:uvod}

U poslednjih 30 godina svedoci smo neverovatnog napretka kompjuterskih tehnologija. 
Računari su za veoma kratko vreme prešli put od čuda tehnike koje je dozvoljeno posmatrati isključivo kroz stakleni zid serverske sobe, 
do uređaja čije se korišćenje podrazumeva u svakodnevnom radu čoveka. Broj uređaja koje možemo smatrati računarima se konstantno povećava iz godine u godinu. 
Od mobilnih telefona, preko prenosnih računara, pa sve do pametnih veš-mašina, računari su postali sastavni (vrlo često i centralni) deo uređaja za koje, 
do pre samo par godina, nismo mogli ni da pretpostavimo da će postati "pametni".
\par
Ovaj fenomen eksplozije broja računara i njegovih primena deoveo je do nekih logičnih posledica. 
Arhitektura procesora od uređaja do uređaja postala je izuzetno šarolika. Zahtevi za uštedom memorije, procesorskog vremena i energije (struje) postali su primarni na uređajima koji nisu 
(i ne mogu biti) na konstantnom izvoru napajanja. Optimizacija je ponovo postala ključni deo problema u razvoju softvera. 

\par
Sa druge strane postoji velika potražnja za softverom koji rešava raznovrsne problema, a koji se pritom izvršava na još raznorodnijim arhitekturama i platformama.
Veliki broj problema koji može biti rešen softverski sa jedne strane i nedovoljan broj razvijaoca softvera sa druge nam govori da je brz razvoj sofvera neophodan kako bi svi problemi 
mogli da se reše u razumnom roku. Način na koji industrija odgovara na taj izazov godinama unazad bio je uopštavanje arhitekture računara koji je omogućio razvijaocima softvera 
da na gotovo isti (ili veoma sličan) način i sa istim alatima i jezicima razvijaju softver za veoma različite platforme. Posledica takvog pristupa je da uopšteni model arhitekture gotovo uvek zanemaruje 
naprednije mogućnosti modernih arhitektura procesora. Korišćenjem samo osnovnih hardverskih funkcionalnosti procesora dolazimo do programa koju su veoma malo (ako uopšte) optimizovani.

\par 
Moderni programski prevodioci uglavnom primenjuju neke statičke tehnike optimizacije, primenjujući različite 
\emph{transformacije} koda koje čuvaju semantičko značenje, kako bi proizveli što optimizovaniji izvorni kod, ali tu nastaju novi problemi. 
Niz transformacija koji daje dobre rezultate na jednoj arhitekturi i za jedan tip algoritamskog problema, 
na drugoj arhitekturi i za drugi tip problema može proizvesti rezultat koji je lošiji od neoptimizovanog rešenja.
Rešenje ovog problema se nazire u konfigurabilnosti redosleda i ulaznih parametara ovih transformacija.
\par
U ovom radu opisujemo jedan pristup optimizaciji u procesu prevođenja koji je nezavisan od platforme i arhitekture. 
Suština ove metode prevođenja je u dodatnom sloju koji se nalazi između izvornog koda i prevodioca. 
Svrha tog sloja je da proizvede optimizovaniji \emph{izvorni k\^{o}d} koji se zatim prosleđuje 
prevodiocu. Kako postoje različiti načini transformacije jednog izvornog koda u drugi, i kako ne postoji jedan statički niz transformacija i njihovih konfiguracija koji bi dao optimalne rezultate za sve probleme i platforme, 
jasno je da odabir transformacija i ulazne parametre tih tranformacija moramo odabirati naći nekakvom pametnom pretragom. 
Taj proces pretrage parametara nazivamo \emph{"Iterativna kompilacija"} \cite{kisuki2000iterative}.
\par
Ovaj rad organizovan je na sledeći način. 
U odeljku \ref{sec:transformacije} opisujemo neke od transformacija izvornog koda koje je moguće koristiti pri optimizaciji. 
Koncentrišemo se (naravno) na one transformacije koje su konfigurabilne. Pokazujemo na koji način ove transformacije utiču na performanse i kako se mogu kombinovati. 
U odeljku \ref{sec:pretraga} poredimo različite metode pretrage ulaznih parametara niza transformacija.
U odeljku \ref{sec:performanse} poredimo performanse programa prevedenih na ovaj način kroz različite repere i realne programe, i poredimo potrošnju energije tih programa.
Konačno, dajemo zaključak na osnovu rezultata merenja performansi i potrošnje energije u odeljku \ref{sec:zakljucak}.


\section{Metode transformacija}
\label{sec:transformacije}

Optimizacija kompilatora za cilj ima da minimizuje ili maksimizuje određena svojstva izvršnog koda programa (npr. potrebnu procesorsku energija) i obično se implementira u obliku niza optimizacionih transformacija. Transformacije su izmene koje se vrše nad kodom kako bi se dobile željene performanse pri njegovom izvršavanju uz uslov da izmenjen kod mora da bude semantički ekvivalentan originalnom. Optimizacija petlji je veoma značajna zato što je procenat vremena koje programi pri izvršavanju provode u petljama veliki. Iz tog razloga ćemo se u ovom poglavlju većim delom koncentrisati na njima.  \\

\textbf{Odmotavanje petlji} (eng. loop unrolling) - Koristi se za smanjivanje vremena koje je potrebno za
izvršavanje petlje po cenu povećavanja veličine koda koji joj odgovara. Cilj je da se u petlji
smanji broj instrukcija koje se vezuju za kontrolu toka petlje. Odmotavanje petlji obično ima
veliki doprinos kada u telu petlje postoje naredbe koje su nezavisne, odnosno mogu da se
paralelno izvršavaju. Ovo se ostvaruje pružanjem većeg broja instrukcija hardveru nego u 
slučaju originalnog koda.\\
Primer petlje koja vrši sve iteracije bez odmotavanja:
\begin{lstlisting}

 int x;
 for (x = 0; x < 100; x++)
 {
     delete(x);
 }
\end{lstlisting}
i verzija u kojoj je upotrebljeno odmotavanje:
\begin{lstlisting}
 int x; 
 for (x = 0; x < 100; x += 5)
 {
     delete(x);
     delete(x + 1);
     delete(x + 2);
     delete(x + 3);
     delete(x + 4);
 }
\end{lstlisting}


\textbf{Podela na blokove} (eng. loop tiling) - Telo petlje se deli na manje blokove kako bi se osiguralo
da lokalni podaci koji se u njemu koriste ostaju u keš memoriji sve dok ne budu opet bili potrebni.
Doprinos se ogleda u smanjenom broju promašaja keš memorije, kao i energije memorijskog sistema koja
bi bila utrošena na prikupljanje podataka sa alternativnih izvora.\\
Primer koda koji vrši množenje matrica:

\begin{lstlisting}
  int i, j, a[100][100], b[100], c[100];
  int n = 100;
  for (i = 0; i < n; i++) {
    c[i] = 0;
    for (j = 0; j < n; j++) {
      c[i] = c[i] + a[i][j] * b[j];
    }
  }
\end{lstlisting}
i njemu odgovarajuća verzija koja deli prostor iteracije na blokove:
\begin{lstlisting}
  int i, j, x, y, a[100][100], b[100], c[100];
  int n = 100;
  for (i = 0; i < n; i += 2) {
    c[i] = 0;
    c[i + 1] = 0;
    for (j = 0; j < n; j += 2) {
      for (x = i; x < min(i + 2, n); x++) {
        for (y = j; y < min(j + 2, n); y++) {
          c[x] = c[x] + a[x][y] * b[y];
        }
      }
    }
  }
\end{lstlisting}

\textbf{Podela petlji} (eng. loop fission) deli telo petlje na dve ili više različitih petlji. Doprinos je u ovom slučaju smanjenje broja promašaja instrukcijske keš memorije i stvaranje mogućnosti da se, ukoliko su tela novonastalih petlji dovoljno mala, koriste baferi petlji (eng. loop buffer) \footnote{Bafer petlje je mala, jako brza memorija koja čuva određen broj vremenski skoro korišćenih naredbi. Ukoliko je bafer petlje dovoljno veliki da sadrži sve naredbe tela petlje, onda je potrebno samo jednom uzeti te informacije iz memorije, i to pri prvoj iteraciji \cite{stallings2000computer}} Negativne posledice podele petlji su povećana potreba za energijom memorijskog sistema usled smanjenja vremenske lokalnosti podataka (eng. temporal locality).\\
Primer petlje u kojoj vršimo dve naredbe:
\begin{lstlisting}
  int i, a[100], b[100];
  for (i = 0; i < 100; i++)
  {
    a[i] = 1; 
    b[i] = 2;
  }
\end{lstlisting}
koju delimo na dve petlje sa po jednom naredbom koje imaju isti opseg:
\begin{lstlisting}
  int i, a[100], b[100];
  for (i = 0; i < 100; i++)
    a[i] = 1;                     
  for (i = 0; i < 100; i++)
    b[i] = 2;
\end{lstlisting}

\textbf{Spajanje petlji} (eng. loop fusion) predstavlja transformaciju suprotnu podeli petlji. Kombinuje tela dve ili više petlji koje imaju iste
granice u jednu. Ukoliko petlje koje spajamo koriste iste podatke, ovom transformacijom povećavamo
njihovu lokalnost. Smanjenjem broja instrukcija koje se koriste za logiku kontrole toka se 
umanjuje i potrebna ukupna procesorska energija.\\

\textbf{Popunjavanje niza} (eng. array padding) postavlja dimenziju niza na novu vrednost. Niz mora biti lokalna varijabla, a njegova dimenzija konstanta vrednost.

\section{Pretraga ulaznih parametara}
\label{sec:pretraga}
Optimizacione transformacije međusobno imaju različite uticaje na kod. Uprkos tome što transformacije koristimo kako bi se u kodu ispoljile njihove pozitivne osobine, treba imati u vidu da loše kombinovanje nekih transformacija može rezultirati neefikasnijim kodom od originalnog. \cite{kisuki2000iterative} Primećuje se da je
nalaženje optimalnog niza transformacija težak posao. \cite{Fursin2005} Suština iterativne kompilacije
je traženje odgovora na pitanje koje transformacije je potrebno primeniti i sa kojim parametrima kako bi izvršni kod dobio željenu efikasnost. U ovom poglavlju ćemo opisati neke od elemenata koji su od velike važnosti pri traženju što efikasnijeg koda.
\subsection{Algoritmi pretrage}
\label{sec:pretrage}

Prostor pretrage (eng. search space) sadrži različite kombinacije parametara za koje se testira efikasnost kompajliranog programa. Kako bismo efikasno tražili optimalnu kombinaciju parametara koju ćemo na kraju i koristiti potrebno je da se što lakše krećemo po prostoru pretrage zato koristimo algoritme pretrage. Navešćemo sada neke algoritme pretrage uz načine njihovog funkcionisanja. Primenu ovih algoritama nad konkretnim podacima kao i širi spisak možete videti u \cite{kisuki2000iterative} \\

\textbf{Genetski algoritam} (eng. genetic algorithm). Prvo se slučajnim izborom bira određen broj kombinacija koje proglašavamo početnom populacijom. Zatim se vrši ukrštanje različitih kombinacija, a nakon toga mutacija u željenoj meri. Na kraju se evaluira nova populacija i ukoliko nije dostignut cilj nastavlja se sa primenom algoritma.\\

\textbf{Pretraga mreže} (eng. grid search). Predstavlja tradicionalni pristup problemu optimizacije većeg broja parametara (eng. hyperparameter optimization). Sastoji se od generisanja različitih tačaka unutar mreže koje su u stvari kombinacije različitih vrednosti parametara. Ove tačke se testiraju i dalji rad algoritma pretrage se fokusira na prostor u okolini tačaka koje su se pokazale kao efikasne u tom trenutku. Grafički prikaz mreže tačaka i regiona polja pretrage koji su nam od značaja se može videti na Slika \ref{fig:grid} \\



\textbf{Slučajna pretraga} (eng. random search). Parametri se generišu slučajnim izborom.

\section{Performanse}
\label{sec:performanse}

\section{Zaključak}
\label{sec:zakljucak}



\addcontentsline{toc}{section}{Literatura}
\appendix
\bibliography{seminarski} 
\bibliographystyle{plain}



\end{document}
